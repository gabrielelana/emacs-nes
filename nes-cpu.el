;; -*- lexical-binding: t -*-

(eval-when-compile (require 'cl-lib))

(require 'nes-dma)
(require 'nes-instruction)
(require 'nes-interrupt)
(require 'nes-keypad)
(require 'nes-ppu)
(require 'nes-util)

;; https://wiki.nesdev.com/w/index.php/CPU_registers
(cl-defstruct (nes/cpu-register
               (:conc-name nes/cpu-register->))
  (acc 0)
  (idx-x 0)
  (idx-y 0)
  (pc 0)
  (sp #x01fd)

  ;; status register
  (sr-carry nil)
  (sr-zero nil)
  (sr-interrupt t)
  (sr-decimal nil)
  (sr-break t)
  (sr-reserved t)
  (sr-overflow nil)
  (sr-negative nil))

(cl-defstruct (nes/cpu-bus
            (:conc-name nes/cpu-bus->))
  (ram nil)
  (prg-rom (lambda (ignored))))

(cl-defstruct (nes/cpu
            (:conc-name nes/cpu->))
  (cycles 0)
  (ppu nil)
  (dma nil)
  (keypad nil)
  (bus (make-nes/cpu-bus))
  (register (make-nes/cpu-register))
  (interrupt nil))

(defun nes/cpu--bus-read (cpu addr)
  "Read byte at ADDR of CPU bus."
  (let ((b (nes/cpu->bus cpu))
        (ppu (nes/cpu->ppu cpu)))
    (cond
     ((< addr #x0800) (aref (nes/cpu-bus->ram b) addr))
     ((< addr #x2000) (nes/cpu--bus-read cpu (- addr #x0800)))
     ((< addr #x4000) (nes/ppu-read ppu (+ (mod addr #x0008) #x2000)))
     ((eq addr #x4016) (nes/keypad-read (nes/cpu->keypad cpu))) ; 1P
     ;; ((eq addr #x4017) (nes/keypad-read (nes/cpu->keypad c))) ;; 2P
     ((>= addr #x8000) (funcall (nes/cpu-bus->prg-rom b) addr))
     (t 0))))

(defun nes/cpu--bus-write (cpu addr data)
  "Write byte DATA to ADDR of CPU bus."
  (let ((b (nes/cpu->bus cpu))
        (ppu (nes/cpu->ppu cpu)))
    (cond
     ((< addr #x2000) (aset (nes/cpu-bus->ram b) (% addr #x0800) data))
     ((< addr #x4000) (nes/ppu-write ppu (+ (% addr #x0008) #x2000) data))
     ;; ((< addr #x4014) ( ... )) ;; APU
     ((eq addr #x4014) (nes/dma-request-transfer (nes/cpu->dma cpu) data))
     ((eq addr #x4016) (nes/keypad-write (nes/cpu->keypad cpu) data))
     ;; ((eq addr #x4017) (nes/keypad-write (nes/cpu->keypad c) data))  ;; 2P
     )))

(defun nes/cpu-read (cpu addr &optional size)
  "Read SIZE data at ADDR of CPU bus.

SIZE can be :byte or :word"
  (setq size (or size :byte))
  (setq addr (logand addr #xffff))
  (if (eq size :word)
      (logior
       (logand (nes/cpu--bus-read cpu addr) #xFF)
       (logand (ash (nes/cpu--bus-read cpu (1+ addr)) 8) #xFF00))
    (logand (nes/cpu--bus-read cpu addr) #xFF)))

(defun nes/cpu-write (cpu addr data)
  "Write DATA to ADDR of CPU bus."
  (nes/cpu--bus-write cpu addr data))

(defun nes/cpu-push (cpu data)
  "Push DATA to stack of CPU."
  (let* ((register (nes/cpu->register cpu))
         (addr (nes/cpu-register->sp register)))
    (nes/cpu-write cpu (logior #x100 (logand addr #x0ff)) data)
    (setf (nes/cpu-register->sp register) (1- addr))))

(defun nes/cpu-pull (cpu)
  "Pull byte from stack of CPU."
  (let* ((register (nes/cpu->register cpu))
         (addr (1+ (nes/cpu-register->sp register))))
    (setf (nes/cpu-register->sp register) addr)
    (nes/cpu-read cpu (logior #x100 (logand addr #x0ff)))))

(defun nes/cpu-status-register (cpu)
  "Return status register of CPU."
  (let ((r (nes/cpu->register cpu)))
    (logior (ash (if (nes/cpu-register->sr-negative r)  1 0) 7)
            (ash (if (nes/cpu-register->sr-overflow r)  1 0) 6)
            (ash (if (nes/cpu-register->sr-reserved r)  1 0) 5)
            (ash (if (nes/cpu-register->sr-break r)     1 0) 4)
            (ash (if (nes/cpu-register->sr-decimal r)   1 0) 3)
            (ash (if (nes/cpu-register->sr-interrupt r) 1 0) 2)
            (ash (if (nes/cpu-register->sr-zero r)      1 0) 1)
            (ash (if (nes/cpu-register->sr-carry r)     1 0) 0))))

(defun nes/cpu-push-status-register (cpu)
  "Push status register to stack of CPU."
  (nes/cpu-push cpu (nes/cpu-status-register cpu)))

(defun nes/cpu-pull-status-register (cpu)
  "Pull byte from stack and use it to set status register of CPU."
  (let ((data (nes/cpu-pull cpu))
        (r (nes/cpu->register cpu)))
    (setf (nes/cpu-register->sr-negative r)  (nes--logbitp 7 data))
    (setf (nes/cpu-register->sr-overflow r)  (nes--logbitp 6 data))
    (setf (nes/cpu-register->sr-reserved r)  (nes--logbitp 5 data))
    (setf (nes/cpu-register->sr-break r)     (nes--logbitp 4 data))
    (setf (nes/cpu-register->sr-decimal r)   (nes--logbitp 3 data))
    (setf (nes/cpu-register->sr-interrupt r) (nes--logbitp 2 data))
    (setf (nes/cpu-register->sr-zero r)      (nes--logbitp 1 data))
    (setf (nes/cpu-register->sr-carry r)     (nes--logbitp 0 data))))

(defun nes/cpu-reset (cpu)
  "Reset CPU."
  (let ((r (nes/cpu->register cpu)))
    (setf (nes/cpu-register->sp r) #xFD)
    (setf (nes/cpu-register->pc r) (nes/cpu-read cpu #xFFFC :word))
    (setf (nes/cpu-register->sr-carry r) nil)
    (setf (nes/cpu-register->sr-zero r) nil)
    (setf (nes/cpu-register->sr-interrupt r) t)
    (setf (nes/cpu-register->sr-decimal r) nil)
    (setf (nes/cpu-register->sr-break r) t)
    (setf (nes/cpu-register->sr-reserved r) t)
    (setf (nes/cpu-register->sr-overflow r) nil)
    (setf (nes/cpu-register->sr-negative r) nil)))

(defun nes/cpu-nmi (c)
  (let ((register (nes/cpu->register c)))
    (nes/interrupt-deassert-nmi (nes/cpu->interrupt c))
    (setf (nes/cpu-register->sr-break register) nil)
    (nes/cpu-push c (logand #xFF (ash (nes/cpu-register->pc register) -8)))
    (nes/cpu-push c (logand #xFF (nes/cpu-register->pc register)))
    (nes/cpu-push-status-register c)
    (setf (nes/cpu-register->sr-interrupt register) t)
    (setf (nes/cpu-register->pc register) (nes/cpu-read c #xFFFA :word))))

(defun nes/cpu-irq (c)
  (let ((register (nes/cpu->register c)))
    (nes/cpu-push c (logand #xff (ash (nes/cpu-register->pc register) -8)))
    (nes/cpu-push c (logand #xff (nes/cpu-register->pc register)))
    (nes/cpu-push-status-register c)
    (setf (nes/cpu-register->sr-interrupt register) t)
    (setf (nes/cpu-register->pc register) (nes/cpu-read c #xfffe :word))))

(defun nes/cpu--get-instruction-operand-and-cycle (cpu mode)
  "Return current operand and cycle's cost given an addressing MODE of CPU."
  (let ((register (nes/cpu->register cpu))
        base-addr
        data-addr
        addr
        idx-x
        idx-y
        cycle)
    ;; Sorted, most used addressing mode first, according to
    ;; http://web.archive.org/web/20190319195151/http://blargg.8bitalley.com/nes-emu/6502.html
    (cond
     ;; Zero Page
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#r8
     ((eq mode :zero-page)
      (cons (nes/cpu--fetch cpu) 0))
     ;; Absolute
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#a16
     ((eq mode :absolute)
      (cons (nes/cpu--fetch cpu :word) 0))
     ;; Immediate
     ;; https://www.pagetable.com/c64ref/6502/?tab=3##d8
     ((eq mode :immediate)
      (cons (nes/cpu--fetch cpu) 0))
     ;; X-Indexed Absolute
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#a16,X
     ((eq mode :absolute-x)
      (setq addr (nes/cpu--fetch cpu :word)
            idx-x (nes/cpu-register->idx-x register)
            cycle (if (eq (logand addr #xFF00) (logand (+ addr idx-x) #xFF00))
                      0
                    1))
      (cons (logand (+ addr idx-x) #xFFFF) cycle))
     ;; Accumulator
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#A
     ((eq mode :accumulator)
      '(nil . 0))
     ;; X-Indexed Zero Page
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#a8,X
     ((eq mode :zero-page-x)
      (cons (logand (+ (nes/cpu--fetch cpu)
                       (nes/cpu-register->idx-x register))
                    #xFF)
            0))
     ;; Y-Indexed Zero Page
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#a8,Y
     ((eq mode :zero-page-y)
      (cons (logand (+ (nes/cpu--fetch cpu)
                       (nes/cpu-register->idx-y register))
                    #xFF)
            0))
     ;; Implied
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#-
     ((eq mode :implied)
      '(nil . 0))
     ;; Relative
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#r8
     ((eq mode :relative)
      (setq base-addr (nes/cpu--fetch cpu)
            addr (if (< base-addr #x80)
                     (+ base-addr (nes/cpu-register->pc register))
                   (- (+ base-addr (nes/cpu-register->pc register)) 256))
            cycle (if (not (eq (logand addr #xFF00) (logand (nes/cpu-register->pc register) #xFF00))) 1 0))
      (cons addr cycle))
     ;; Y-Indexed Absolute
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#a16,Y
     ((eq mode :absolute-y)
      (setq addr (nes/cpu--fetch cpu :word)
            idx-y (nes/cpu-register->idx-y register)
            cycle (if (eq (logand addr #xFF00) (logand (+ addr idx-y) #xFF00))
                      0 1))
      (cons (logand (+ addr idx-y) #xFFFF) cycle))
     ;; X-Indexed Zero Page Indirect
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#(a8,X)
     ((eq mode :pre-indexed-indirect)
      (setq base-addr (logand (+ (nes/cpu--fetch cpu) (nes/cpu-register->idx-x register))
                              #xFF)
            addr (logand (+ (nes/cpu-read cpu base-addr)
                            (ash (nes/cpu-read cpu (logand (1+ base-addr) #xFF)) 8))
                         #xFFFF)
            ;; cycle (if (/= (logand addr #xFF00) (logand base-addr #xFF00)) 1 0)
            )
      (cons addr 0))
     ;; Zero Page Indirect Y-Indexed
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#(a8),Y
     ((eq mode :post-indexed-indirect)
      (setq data-addr (nes/cpu--fetch cpu)
            base-addr (+ (nes/cpu-read cpu data-addr)
                         (ash (nes/cpu-read cpu (logand (1+ data-addr) #xFF)) 8))
            addr (logand (+ base-addr (nes/cpu-register->idx-y register)) #xFFFF)
            cycle (if (/= (logand addr #xFF00) (logand base-addr #xFF00)) 1 0))
      (cons addr cycle))
     ;; Absolute Indirect
     ;; https://www.pagetable.com/c64ref/6502/?tab=3#(a16)
     ((eq mode :indirect-absolute)
      (setq data-addr (nes/cpu--fetch cpu :word))
      (cons (logand (+ (nes/cpu-read cpu data-addr)
                       (ash (nes/cpu-read cpu (logior (logand data-addr #xFF00)
                                                      (logand (1+ (logand data-addr #xFF)) #xFF)))
                            8))
                    #xFFFF)
            0)))))

(defun nes/cpu--fetch (cpu &optional size)
  "Read SIZE data at program counter of CPU bus.

SIZE can be :byte or :word"
  (let ((size (or size :byte))
        (addr (nes/cpu-register->pc (nes/cpu->register cpu))))
    (cl-incf (nes/cpu-register->pc (nes/cpu->register cpu)) (if (eq size :word) 2 1))
    (nes/cpu-read cpu addr size)))

(defun nes/cpu-set-working-ram (cpu ram)
  (setf (nes/cpu-bus->ram (nes/cpu->bus cpu)) ram))

(defun nes/cpu-set-program-rom (cpu rom-func)
  (setf (nes/cpu-bus->prg-rom (nes/cpu->bus cpu)) rom-func))

;; TODO: make nes/cpu->cycles accumulate all the cycles with as 16 bit counter
(defun nes/cpu-step (cpu)
  "Make CPU run next instruction."
  (when (nes/interrupt->nmi (nes/cpu->interrupt cpu))
    (nes/cpu-nmi cpu))
  (nes/interrupt-clear (nes/cpu->interrupt cpu))
  (let* ((opcode (nes/cpu--fetch cpu))
         (instruction (aref nes/instruction:MAP opcode))
         (instruction-mode (nes/instruction->mode instruction))
         (instruction-name (nes/instruction->name instruction))
         (operand-and-cycle (nes/cpu--get-instruction-operand-and-cycle cpu instruction-mode))
         (operand (car operand-and-cycle))
         (instruction-cycles (aref nes/instruction:CYCLES opcode))
         (penalty-cycles (cdr operand-and-cycle)))
    (setf (nes/cpu->cycles cpu) 0)
    (funcall (nes/instruction->func instruction) cpu operand instruction-mode)
    (+ (nes/cpu->cycles cpu)
       instruction-cycles
       ;; NOTE: we are going to pay the extra cycle for crossing memory page
       ;; only if the op did something aka changed the cycle aka ex. jumped
       ;; TODO: make nes/instruction-* take cycles parameter
       ;; TODO: make nes/instruction-* take penalty-cycle parameter
       ;; TODO: make nes/instruction-* function return taken-cycles
       (if (or
            (equal "LDA" instruction-name)
            (equal "LDX" instruction-name)
            (equal "LDY" instruction-name)
            (equal "LAX" instruction-name)
            (equal "NOPI" instruction-name)
            (> (nes/cpu->cycles cpu) 0))
           penalty-cycles
         0))))

(defun nes/cpu-step-count (cpu count)
  "Execute next COUNT CPU instructions."
  (let ((total-cycles 0))
    (dotimes (_ count)
      (when (nes/interrupt->nmi (nes/cpu->interrupt cpu))
        (nes/cpu-nmi cpu))
      (nes/interrupt-clear (nes/cpu->interrupt cpu))
      (let* ((opcode (nes/cpu--fetch cpu))
             (r0 (nes/cpu--classify opcode))
             (sym (nth 0 r0))
             (mode (nth 1 r0))
             (cost (nth 2 r0))
             (r1 (nes/cpu--get-instruction-operand-and-cycle cpu mode))
             (op (car r1))
             (penalty (cdr r1))
             (cycles 0))
        (setf (nes/cpu->cycles cpu) 0)
        (cond
         ;; LDA: Load Accumulator
         ((eq sym :LDA)
          (let ((data (if (eq mode :immediate)
                          op
                        (nes/cpu-read cpu op)))
                (register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->acc register) data)
            (setq cycles (+ penalty))
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; BNE
         ((eq sym :BNE)
          (let ((register (nes/cpu->register cpu)))
            (unless (nes/cpu-register->sr-zero register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; JMP: Jump
         ((eq sym :JMP)
          (setf (nes/cpu-register->pc (nes/cpu->register cpu)) op))
         ;; INX: Increment X Register
         ((eq sym :INX)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (1+ (nes/cpu-register->idx-x register)) #xff)))
            (setf (nes/cpu-register->idx-x register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; BPL
         ((eq sym :BPL)
          (let ((register (nes/cpu->register cpu)))
            (unless (nes/cpu-register->sr-negative register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; CMP: Compare
         ((eq sym :CMP)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (compared (- acc data)))
            (nes/instruction--set-zero-and-negative-flags register compared)
            (setf (nes/cpu-register->sr-carry register) (>= compared 0))))
         ;; BMI
         ((eq sym :BMI)
          (let ((register (nes/cpu->register cpu)))
            (when (nes/cpu-register->sr-negative register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BEQ
         ((eq sym :BEQ)
          (let ((register (nes/cpu->register cpu)))
            (when (nes/cpu-register->sr-zero register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BIT
         ((eq sym :BIT)
          (let* ((data (nes/cpu-read cpu op))
                 (register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->sr-negative register) (nes--logbitp 7 data))
            (setf (nes/cpu-register->sr-overflow register) (nes--logbitp 6 data))
            (setf (nes/cpu-register->sr-zero register) (zerop (logand (nes/cpu-register->acc register) data)))))
         ;; STA: Store Accumulator
         ((eq sym :STA)
          (nes/cpu-write cpu op (nes/cpu-register->acc (nes/cpu->register cpu))))
         ;; DEX: Decrement X Register
         ((eq sym :DEX)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (1- (nes/cpu-register->idx-x register)) #xff)))
            (setf (nes/cpu-register->idx-x register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; INY: Increment Y Register
         ((eq sym :INY)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (1+ (nes/cpu-register->idx-y register)) #xff)))
            (setf (nes/cpu-register->idx-y register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; TAY: Transfer Accumulator to Y
         ((eq sym :TAY)
          (let* ((register (nes/cpu->register cpu))
                 (data (nes/cpu-register->acc register)))
            (setf (nes/cpu-register->idx-y register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; LDX: Load X Register
         ((eq sym :LDX)
          (let ((data (if (eq mode :immediate)
                          op
                        (nes/cpu-read cpu op)))
                (register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->idx-x register) data)
            (setq cycles (+ penalty))
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; LDY: Load Y Register
         ((eq sym :LDY)
          (let ((data (if (eq mode :immediate)
                          op
                        (nes/cpu-read cpu op)))
                (register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->idx-y register) data)
            (setq cycles (+ penalty))
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; STX: Store X Register
         ((eq sym :STX)
          (nes/cpu-write cpu op (nes/cpu-register->idx-x (nes/cpu->register cpu))))
         ;; STY: Store Y Register
         ((eq sym :STY)
          (nes/cpu-write cpu op (nes/cpu-register->idx-y (nes/cpu->register cpu))))
         ;; TAX: Transfer Accumulator to X
         ((eq sym :TAX)
          (let* ((register (nes/cpu->register cpu))
                 (data (nes/cpu-register->acc register)))
            (setf (nes/cpu-register->idx-x register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; TSX: Transfer Stack Pointer to X
         ((eq sym :TSX)
          (let* ((register (nes/cpu->register cpu))
                 (data (nes/cpu-register->sp register)))
            (setf (nes/cpu-register->idx-x register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; TXA: Transfer X to Accumulator
         ((eq sym :TXA)
          (let* ((register (nes/cpu->register cpu))
                 (data (nes/cpu-register->idx-x register)))
            (setf (nes/cpu-register->acc register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; TXS: Transfer X to Stack Pointer
         ((eq sym :TXS)
          (let ((register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->sp register)
                  (nes/cpu-register->idx-x register))))
         ;; TYA: Transfer Y to Accumulator
         ((eq sym :TYA)
          (let* ((register (nes/cpu->register cpu))
                 (data (nes/cpu-register->idx-y register)))
            (setf (nes/cpu-register->acc register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; PHP: Push Processor Status
         ;; In the byte pushed, bit 5 is always set to 1, and bit 4 is 1 if from an instruction (PHP or BRK)
         ;; see https://wiki.nesdev.com/w/index.php/Status_flags#The_B_flag
         ((eq sym :PHP)
          (let* ((r (nes/cpu->register cpu))
                 (old-break (nes/cpu-register->sr-break r))
                 (old-reserved (nes/cpu-register->sr-reserved r)))
            (setf (nes/cpu-register->sr-break r) t)
            (setf (nes/cpu-register->sr-reserved r) t)
            (nes/cpu-push-status-register cpu)
            (setf (nes/cpu-register->sr-break r) old-break)
            (setf (nes/cpu-register->sr-reserved r) old-reserved)))
         ;; PHA: Push Accumulator
         ((eq sym :PHA)
          (nes/cpu-push cpu (nes/cpu-register->acc (nes/cpu->register cpu))))
         ;; PLA: Pull Accumulator
         ((eq sym :PLA)
          (let ((register (nes/cpu->register cpu))
                (data (nes/cpu-pull cpu)))
            (setf (nes/cpu-register->acc register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; PLP: Pull Processor Status
         ;; Two instructions (PLP and RTI) pull a byte from the stack and set all the flags. They ignore bits 5 and 4.
         ;; see https://wiki.nesdev.com/w/index.php/Status_flags#The_B_flag
         ((eq sym :PLP)
          (let* ((r (nes/cpu->register cpu))
                 (current-break (nes/cpu-register->sr-break r))
                 (current-reserved (nes/cpu-register->sr-reserved r)))
            (nes/cpu-pull-status-register cpu)
            (setf (nes/cpu-register->sr-break r) current-break)
            (setf (nes/cpu-register->sr-reserved r) current-reserved)))
         ;; SEC: Set Carry Flag
         ((eq sym :SEC)
          (setf (nes/cpu-register->sr-carry (nes/cpu->register cpu)) t))
         ;; SED: Set Decimal Flag
         ((eq sym :SED)
          (setf (nes/cpu-register->sr-decimal (nes/cpu->register cpu)) t))
         ;; SEI: Set Interrupt Disable
         ((eq sym :SEI)
          (setf (nes/cpu-register->sr-interrupt (nes/cpu->register cpu)) t))
         ;; CLC: Clear Carry Flag
         ((eq sym :CLC)
          (setf (nes/cpu-register->sr-carry (nes/cpu->register cpu)) nil))
         ;; CLD: Clear Decimal Mode
         ((eq sym :CLD)
          (setf (nes/cpu-register->sr-decimal (nes/cpu->register cpu)) nil))
         ;; CLI: Clear Interrupt Disable
         ((eq sym :CLI)
          (setf (nes/cpu-register->sr-interrupt (nes/cpu->register cpu)) nil))
         ;; CLV: Clear Overflow Flag
         ((eq sym :CLV)
          (setf (nes/cpu-register->sr-overflow (nes/cpu->register cpu)) nil))
         ;; INC: Increment Memory
         ((eq sym :INC)
          (let ((data (logand (1+ (nes/cpu-read cpu op)) #xff))
                (register (nes/cpu->register cpu)))
            (nes/cpu-write cpu op data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; DEC: Decrement Memory
         ((eq sym :DEC)
          (let ((data (logand (1- (nes/cpu-read cpu op)) #xff))
                (register (nes/cpu->register cpu)))
            (nes/cpu-write cpu op data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; DEY: Decrement Y Register
         ((eq sym :DEY)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (1- (nes/cpu-register->idx-y register)) #xff)))
            (setf (nes/cpu-register->idx-y register) data)
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; ADC: Add with Carry
         ((eq sym :ADC)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (result (+ acc
                            data
                            (if (nes/cpu-register->sr-carry register)
                                1 0))))
            (nes/instruction--set-zero-and-negative-flags register result)
            (setf (nes/cpu-register->sr-carry register) (> result #xff))
            (setf (nes/cpu-register->sr-overflow register)
                  (and (not (nes--logbitp 7 (logxor acc data)))
                       (nes--logbitp 7 (logxor acc result))))
            (setf (nes/cpu-register->acc register) (logand result #xFF))))
         ;; SBC: Subtract with Carry
         ((eq sym :SBC)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (result (- acc
                            data
                            (if (nes/cpu-register->sr-carry register)
                                0 1))))
            (nes/instruction--set-zero-and-negative-flags register result)
            (setf (nes/cpu-register->sr-carry register) (>= result 0))
            (setf (nes/cpu-register->sr-overflow register)
                  (and (nes--logbitp 7 (logxor acc data))
                       (nes--logbitp 7 (logxor acc result))))
            (setf (nes/cpu-register->acc register) (logand result #xFF))))
         ;; CPX: Compare X Register
         ((eq sym :CPX)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (x (nes/cpu-register->idx-x register))
                 (compared (- x data)))
            (nes/instruction--set-zero-and-negative-flags register compared)
            (setf (nes/cpu-register->sr-carry register) (>= compared 0))))
         ;; CPY: Compare Y Register
         ((eq sym :CPY)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (y (nes/cpu-register->idx-y register))
                 (compared (- y data)))
            (nes/instruction--set-zero-and-negative-flags register compared)
            (setf (nes/cpu-register->sr-carry register) (>= compared 0))))
         ;; AND: Logical And
         ((eq sym :AND)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (result (logand acc data)))
            (nes/instruction--set-zero-and-negative-flags register result)
            (setf (nes/cpu-register->acc register) (logand result #xff))))
         ;; ORA: Logical Inclusive OR
         ((eq sym :ORA)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (result (logior acc data)))
            (nes/instruction--set-zero-and-negative-flags register result)
            (setf (nes/cpu-register->acc register) (logand result #xff))))
         ;; EOR: Exclusive OR
         ((eq sym :EOR)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :immediate)
                           op
                         (nes/cpu-read cpu op)))
                 (acc (nes/cpu-register->acc register))
                 (result (logxor acc data)))
            (nes/instruction--set-zero-and-negative-flags register result)
            (setf (nes/cpu-register->acc register) (logand result #xff))))
         ;; ASL: Arithmetic Shift Left
         ((eq sym :ASL)
          (let* ((register (nes/cpu->register cpu))
                 (data (if (eq mode :accumulator)
                           (nes/cpu-register->acc register)
                         (nes/cpu-read cpu op)))
                 (shifted (logand (ash data 1) #xff)))
            (setf (nes/cpu-register->sr-carry register) (nes--logbitp 7 data))
            (nes/instruction--set-zero-and-negative-flags register shifted)
            (if (eq mode :accumulator)
                (setf (nes/cpu-register->acc register) shifted)
              (nes/cpu-write cpu op shifted))))
         ;; LSR: Logical Shift Right
         ((eq sym :LSR)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (if (eq mode :accumulator)
                                   (nes/cpu-register->acc register)
                                 (nes/cpu-read cpu op))))
                 (shifted (logand (ash data -1) #xff)))
            (setf (nes/cpu-register->sr-carry register) (nes--logbitp 0 data))
            (nes/instruction--set-zero-and-negative-flags register shifted)
            (if (eq mode :accumulator)
                (setf (nes/cpu-register->acc register) shifted)
              (nes/cpu-write cpu op shifted))))
         ;; ROL: Rotate Left
         ((eq sym :ROL)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (if (eq mode :accumulator)
                                   (nes/cpu-register->acc register)
                                 (nes/cpu-read cpu op))))
                 (carry (nes/cpu-register->sr-carry register))
                 (rotated (logand #xff
                                  (logior (ash data 1) (if carry #x01 #x00)))))
            (setf (nes/cpu-register->sr-carry register) (nes--logbitp 7 data))
            (nes/instruction--set-zero-and-negative-flags register rotated)
            (if (eq mode :accumulator)
                (setf (nes/cpu-register->acc register) rotated)
              (nes/cpu-write cpu op rotated))))
         ;; ROR: Rotate Right
         ((eq sym :ROR)
          (let* ((register (nes/cpu->register cpu))
                 (data (logand (if (eq mode :accumulator)
                                   (nes/cpu-register->acc register)
                                 (nes/cpu-read cpu op))))
                 (carry (nes/cpu-register->sr-carry register))
                 (rotated (logand #xff
                                  (logior (ash data -1) (if carry #x80 #x00)))))
            (setf (nes/cpu-register->sr-carry register) (/= (logand data #x01) 0))
            (nes/instruction--set-zero-and-negative-flags register rotated)
            (if (eq mode :accumulator)
                (setf (nes/cpu-register->acc register) rotated)
              (nes/cpu-write cpu op rotated))))
         ;; NOP: No Operation
         ((eq sym :NOP)
          ;; doesn nothing?
          '()
          )
         ;; BVS
         ((eq sym :BVS)
          (let ((register (nes/cpu->register cpu)))
            (when (nes/cpu-register->sr-overflow register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BVC
         ((eq sym :BVC)
          (let ((register (nes/cpu->register cpu)))
            (unless (nes/cpu-register->sr-overflow register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BCS
         ((eq sym :BCS)
          (let ((register (nes/cpu->register cpu)))
            (when (nes/cpu-register->sr-carry register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BCC
         ((eq sym :BCC)
          (let ((register (nes/cpu->register cpu)))
            (unless (nes/cpu-register->sr-carry register)
              (setf (nes/cpu->cycles cpu) (logand (1+ (nes/cpu->cycles cpu)) #xFFFF))
              (setf (nes/cpu-register->pc register) op))))
         ;; BRK
         ((eq sym :BRK)
          (let* ((register (nes/cpu->register cpu))
                 (interrupt (nes/cpu-register->sr-interrupt register)))
            (setf (nes/cpu-register->sr-break register) t)
            (cl-incf (nes/cpu-register->pc register))
            (nes/cpu-push cpu (logand #xFF (ash (nes/cpu-register->pc register) -8)))
            (nes/cpu-push cpu (logand #xFF (nes/cpu-register->pc register)))
            (nes/cpu-push-status-register cpu)
            (unless interrupt
              (setf (nes/cpu-register->sr-interrupt register) t)
              (setf (nes/cpu-register->pc register) (nes/cpu-read cpu #xFFFE :word)))
            (cl-decf (nes/cpu-register->pc register))))
         ;; JSR
         ((eq sym :JSR)
          (let* ((register (nes/cpu->register cpu))
                 (pc (1- (nes/cpu-register->pc register))))
            (nes/cpu-push cpu (logand (ash pc -8) #xFF))
            (nes/cpu-push cpu (logand pc #xFF))
            (setf (nes/cpu-register->pc register) op)))
         ;; RTS
         ((eq sym :RTS)
          (let ((register (nes/cpu->register cpu))
                pc)
            (setq pc (logior (nes/cpu-pull cpu)
                             (ash (nes/cpu-pull cpu) 8)))
            (setf (nes/cpu-register->pc register) (1+ pc))))
         ;; RTI
         ((eq sym :RTI)
          (nes/cpu-pull-status-register cpu)
          (let ((register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->sr-reserved register) t)
            (setf (nes/cpu-register->pc register)
                  (logior (nes/cpu-pull cpu)
                          (ash (nes/cpu-pull cpu) 8)))))
         ;; NOPD
         ((eq sym :NOPD)
          (let ((r (nes/cpu->register cpu)))
            (setf (nes/cpu-register->pc r) (1+ (nes/cpu-register->pc r)))))
         ;; NOPI
         ((eq sym :NOPI)
          (setq cycles (+ penalty)))
         ;; LAX
         ((eq sym :LAX)
          (let ((data (nes/cpu-read cpu op))
                (register (nes/cpu->register cpu)))
            (setf (nes/cpu-register->idx-x register) data)
            (setf (nes/cpu-register->acc register) data)
            (setq cycles (+ penalty))
            (nes/instruction--set-zero-and-negative-flags register data)))
         ;; SAX
         ((eq sym :SAX)
          (let ((r (nes/cpu->register cpu)))
            (nes/cpu-write cpu op
                           (logand (nes/cpu-register->acc r)
                                   (nes/cpu-register->idx-x r)))))
         ;; DCP
         ((eq sym :DCP)
          (let* ((reg (nes/cpu->register cpu))
                 (operated (logand (1- (nes/cpu-read cpu op)) #xFF)))
            (setf (nes/cpu-register->sr-negative reg)
                  (/= (logand (logand (- (nes/cpu-register->acc reg) operated) #x1FF) #x80) 0))
            (setf (nes/cpu-register->sr-zero reg)
                  (= (logand (- (nes/cpu-register->acc reg) operated) #x1FF) 0))
            (nes/cpu-write cpu op operated)))
         ;; ISB
         ((eq sym :ISB)
          (let* ((data (logand (1+ (nes/cpu-read cpu op)) #xFF))
                 (reg (nes/cpu->register cpu))
                 (operated (+ (logand (lognot data) #xFF)
                              (nes/cpu-register->acc reg)
                              (if (nes/cpu-register->sr-carry reg) 1 0))))
            (setf (nes/cpu-register->sr-overflow reg)
                  (and (zerop (logand (logxor (nes/cpu-register->acc reg) data) #x80))
                       (not (zerop (logand (logxor (nes/cpu-register->acc reg) operated) #x80)))))
            (setf (nes/cpu-register->sr-carry reg)
                  (> operated #xFF))
            (nes/instruction--set-zero-and-negative-flags reg operated)
            (setf (nes/cpu-register->acc reg) (logand operated #xFF))
            (nes/cpu-write cpu op data)))
         ;; SLO
         ((eq sym :SLO)
          (let* ((data (nes/cpu-read cpu op))
                 (reg (nes/cpu->register cpu)))
            (setf (nes/cpu-register->sr-carry reg) (nes--logbitp 7 data))
            (setq data (logand (ash data 1) #xFF))
            (setf (nes/cpu-register->acc reg)
                  (logior (nes/cpu-register->acc reg) data))
            (setf (nes/cpu-register->sr-negative reg)
                  (nes--logbitp 7 (nes/cpu-register->acc reg)))
            (setf (nes/cpu-register->sr-zero reg)
                  (= (logand (nes/cpu-register->acc reg) #xFF) 0))
            (nes/cpu-write cpu op data)))
         ;; RLA
         ((eq sym :RLA)
          (let* ((data (nes/cpu-read cpu op))
                 (reg (nes/cpu->register cpu)))
            (setq data (+ (ash data 1)
                          (if (nes/cpu-register->sr-carry reg) 1 0)))
            (setf (nes/cpu-register->sr-carry reg)
                  (nes--logbitp 8 data))
            (setf (nes/cpu-register->acc reg)
                  (logand (logand (nes/cpu-register->acc reg) data) #xFF))
            (setf (nes/cpu-register->sr-negative reg)
                  (nes--logbitp 7 (nes/cpu-register->acc reg)))
            (setf (nes/cpu-register->sr-zero reg)
                  (= (logand (nes/cpu-register->acc reg) #xFF) 0))
            (nes/cpu-write cpu op data)))
         ;; SRE
         ((eq sym :SRE)
          (let* ((data (nes/cpu-read cpu op))
                 (reg (nes/cpu->register cpu)))
            (setf (nes/cpu-register->sr-carry reg)
                  (nes--logbitp 0 data))
            (setq data (ash data -1))
            (setf (nes/cpu-register->acc reg)
                  (logxor (nes/cpu-register->acc reg) data))
            (setf (nes/cpu-register->sr-negative reg)
                  (nes--logbitp 7 (nes/cpu-register->acc reg)))
            (setf (nes/cpu-register->sr-zero reg)
                  (= (logand (nes/cpu-register->acc reg) #xFF) 0))
            (nes/cpu-write cpu op data)))
         ;; RRA
         ((eq sym :RRA)
          (let* ((data (nes/cpu-read cpu op))
                 (reg (nes/cpu->register cpu))
                 (carry (nes--logbitp 0 data))
                 operated)
            (setq data (logior (ash data -1)
                               (if (nes/cpu-register->sr-carry reg) #x80 #x00)))
            (setq operated (+ data (nes/cpu-register->acc reg) (if carry 1 0)))

            (setf (nes/cpu-register->sr-overflow reg)
                  (and (not (nes--logbitp 7 (logxor (nes/cpu-register->acc reg) data)))
                       (nes--logbitp 7 (logxor (nes/cpu-register->acc reg) operated))))

            (setf (nes/cpu-register->sr-carry reg)
                  (> operated #xFF))
            (setf (nes/cpu-register->sr-negative reg)
                  (nes--logbitp 7 operated))
            (setf (nes/cpu-register->sr-zero reg)
                  (= (logand operated #xFF) 0))
            (setf (nes/cpu-register->acc reg) (logand operated #xFF))
            (nes/cpu-write cpu op data)))
         ;; TODO: default clause with user error opcode not handled

         )
        ;; FIX:
        ;; TODO: do not set nes/cpu-cycles but cycles
        ;; TODO: return (+ cycles cost)
        ;; TODO: remove nes/cpu-cycles
        (setq total-cycles
              (+
               total-cycles
               (nes/cpu->cycles cpu)
               cost
               cycles
               (if (> (nes/cpu->cycles cpu) 0)
                   penalty
                 0)))
        ))
    total-cycles
    )
  )

(defun nes/cpu--classify (opcode)
  "Classify OPCODE, return (SYM, MODE, PENALTY)."
  (cond
   ((eq opcode #xA9) '(:LDA :immediate 2))
   ((eq opcode #xA5) '(:LDA :zero-page 3))
   ((eq opcode #xAD) '(:LDA :absolute 4))
   ((eq opcode #xB5) '(:LDA :zero-page-x 4))
   ((eq opcode #xBD) '(:LDA :absolute-x 4))
   ((eq opcode #xB9) '(:LDA :absolute-y 4))
   ((eq opcode #xA1) '(:LDA :pre-indexed-indirect 6))
   ((eq opcode #xB1) '(:LDA :post-indexed-indirect 5))
   ((eq opcode #xA2) '(:LDX :immediate 2))
   ((eq opcode #xA6) '(:LDX :zero-page 3))
   ((eq opcode #xAE) '(:LDX :absolute 4))
   ((eq opcode #xB6) '(:LDX :zero-page-y 4))
   ((eq opcode #xBE) '(:LDX :absolute-y 4))
   ((eq opcode #xA0) '(:LDY :immediate 2))
   ((eq opcode #xA4) '(:LDY :zero-page 3))
   ((eq opcode #xAC) '(:LDY :absolute 4))
   ((eq opcode #xB4) '(:LDY :zero-page-x 4))
   ((eq opcode #xBC) '(:LDY :absolute-x 4))
   ((eq opcode #x85) '(:STA :zero-page 3))
   ((eq opcode #x8D) '(:STA :absolute 4))
   ((eq opcode #x95) '(:STA :zero-page-x 4))
   ((eq opcode #x9D) '(:STA :absolute-x 5))
   ((eq opcode #x99) '(:STA :absolute-y 5))
   ((eq opcode #x81) '(:STA :pre-indexed-indirect 6))
   ((eq opcode #x91) '(:STA :post-indexed-indirect 6))
   ((eq opcode #x86) '(:STX :zero-page 3))
   ((eq opcode #x8E) '(:STX :absolute 4))
   ((eq opcode #x96) '(:STX :zero-page-y 4))
   ((eq opcode #x84) '(:STY :zero-page 3))
   ((eq opcode #x8C) '(:STY :absolute 4))
   ((eq opcode #x94) '(:STY :zero-page-x 4))
   ((eq opcode #x8A) '(:TXA :implied 2))
   ((eq opcode #x98) '(:TYA :implied 2))
   ((eq opcode #x9A) '(:TXS :implied 2))
   ((eq opcode #xA8) '(:TAY :implied 2))
   ((eq opcode #xAA) '(:TAX :implied 2))
   ((eq opcode #xBA) '(:TSX :implied 2))
   ((eq opcode #x08) '(:PHP :implied 3))
   ((eq opcode #x28) '(:PLP :implied 4))
   ((eq opcode #x48) '(:PHA :implied 3))
   ((eq opcode #x68) '(:PLA :implied 4))
   ((eq opcode #x69) '(:ADC :immediate 2))
   ((eq opcode #x65) '(:ADC :zero-page 3))
   ((eq opcode #x6D) '(:ADC :absolute 4))
   ((eq opcode #x75) '(:ADC :zero-page-x 4))
   ((eq opcode #x7D) '(:ADC :absolute-x 4))
   ((eq opcode #x79) '(:ADC :absolute-y 4))
   ((eq opcode #x61) '(:ADC :pre-indexed-indirect 6))
   ((eq opcode #x71) '(:ADC :post-indexed-indirect 5))
   ((eq opcode #xE9) '(:SBC :immediate 2))
   ((eq opcode #xE5) '(:SBC :zero-page 3))
   ((eq opcode #xED) '(:SBC :absolute 4))
   ((eq opcode #xF5) '(:SBC :zero-page-x 4))
   ((eq opcode #xFD) '(:SBC :absolute-x 4))
   ((eq opcode #xF9) '(:SBC :absolute-y 4))
   ((eq opcode #xE1) '(:SBC :pre-indexed-indirect 6))
   ((eq opcode #xF1) '(:SBC :post-indexed-indirect 5))
   ((eq opcode #xE0) '(:CPX :immediate 2))
   ((eq opcode #xE4) '(:CPX :zero-page 3))
   ((eq opcode #xEC) '(:CPX :absolute 4))
   ((eq opcode #xC0) '(:CPY :immediate 2))
   ((eq opcode #xC4) '(:CPY :zero-page 3))
   ((eq opcode #xCC) '(:CPY :absolute 4))
   ((eq opcode #xC9) '(:CMP :immediate 2))
   ((eq opcode #xC5) '(:CMP :zero-page 3))
   ((eq opcode #xCD) '(:CMP :absolute 4))
   ((eq opcode #xD5) '(:CMP :zero-page-x 4))
   ((eq opcode #xDD) '(:CMP :absolute-x 4))
   ((eq opcode #xD9) '(:CMP :absolute-y 4))
   ((eq opcode #xC1) '(:CMP :pre-indexed-indirect 6))
   ((eq opcode #xD1) '(:CMP :post-indexed-indirect 5))
   ((eq opcode #x29) '(:AND :immediate 2))
   ((eq opcode #x25) '(:AND :zero-page 3))
   ((eq opcode #x2D) '(:AND :absolute 4))
   ((eq opcode #x35) '(:AND :zero-page-x 4))
   ((eq opcode #x3D) '(:AND :absolute-x 4))
   ((eq opcode #x39) '(:AND :absolute-y 4))
   ((eq opcode #x21) '(:AND :pre-indexed-indirect 6))
   ((eq opcode #x31) '(:AND :post-indexed-indirect 5))
   ((eq opcode #x49) '(:EOR :immediate 2))
   ((eq opcode #x45) '(:EOR :zero-page 3))
   ((eq opcode #x4D) '(:EOR :absolute 4))
   ((eq opcode #x55) '(:EOR :zero-page-x 4))
   ((eq opcode #x5D) '(:EOR :absolute-x 4))
   ((eq opcode #x59) '(:EOR :absolute-y 4))
   ((eq opcode #x41) '(:EOR :pre-indexed-indirect 6))
   ((eq opcode #x51) '(:EOR :post-indexed-indirect 5))
   ((eq opcode #x09) '(:ORA :immediate 2))
   ((eq opcode #x05) '(:ORA :zero-page 3))
   ((eq opcode #x0D) '(:ORA :absolute 4))
   ((eq opcode #x15) '(:ORA :zero-page-x 4))
   ((eq opcode #x1D) '(:ORA :absolute-x 4))
   ((eq opcode #x19) '(:ORA :absolute-y 4))
   ((eq opcode #x01) '(:ORA :pre-indexed-indirect 6))
   ((eq opcode #x11) '(:ORA :post-indexed-indirect 5))
   ((eq opcode #x24) '(:BIT :zero-page 3))
   ((eq opcode #x2C) '(:BIT :absolute 4))
   ((eq opcode #x0A) '(:ASL :accumulator 2))
   ((eq opcode #x06) '(:ASL :zero-page 5))
   ((eq opcode #x0E) '(:ASL :absolute 6))
   ((eq opcode #x16) '(:ASL :zero-page-x 6))
   ((eq opcode #x1E) '(:ASL :absolute-x 7))
   ((eq opcode #x4A) '(:LSR :accumulator 2))
   ((eq opcode #x46) '(:LSR :zero-page 5))
   ((eq opcode #x4E) '(:LSR :absolute 6))
   ((eq opcode #x56) '(:LSR :zero-page-x 6))
   ((eq opcode #x5E) '(:LSR :absolute-x 7))
   ((eq opcode #x2A) '(:ROL :accumulator 2))
   ((eq opcode #x26) '(:ROL :zero-page 5))
   ((eq opcode #x2E) '(:ROL :absolute 6))
   ((eq opcode #x36) '(:ROL :zero-page-x 6))
   ((eq opcode #x3E) '(:ROL :absolute-x 7))
   ((eq opcode #x6A) '(:ROR :accumulator 2))
   ((eq opcode #x66) '(:ROR :zero-page 5))
   ((eq opcode #x6E) '(:ROR :absolute 6))
   ((eq opcode #x76) '(:ROR :zero-page-x 6))
   ((eq opcode #x7E) '(:ROR :absolute-x 7))
   ((eq opcode #xE8) '(:INX :implied 2))
   ((eq opcode #xC8) '(:INY :implied 2))
   ((eq opcode #xE6) '(:INC :zero-page 5))
   ((eq opcode #xEE) '(:INC :absolute 6))
   ((eq opcode #xF6) '(:INC :zero-page-x 6))
   ((eq opcode #xFE) '(:INC :absolute-x 7))
   ((eq opcode #xCA) '(:DEX :implied 2))
   ((eq opcode #x88) '(:DEY :implied 2))
   ((eq opcode #xC6) '(:DEC :zero-page 5))
   ((eq opcode #xCE) '(:DEC :absolute 6))
   ((eq opcode #xD6) '(:DEC :zero-page-x 6))
   ((eq opcode #xDE) '(:DEC :absolute-x 7))
   ((eq opcode #x18) '(:CLC :implied 2))
   ((eq opcode #x58) '(:CLI :implied 2))
   ((eq opcode #xB8) '(:CLV :implied 2))
   ((eq opcode #x38) '(:SEC :implied 2))
   ((eq opcode #x78) '(:SEI :implied 2))
   ((eq opcode #xEA) '(:NOP :implied 2))
   ((eq opcode #x00) '(:BRK :implied 7))
   ((eq opcode #x20) '(:JSR :absolute 6))
   ((eq opcode #x4C) '(:JMP :absolute 3))
   ((eq opcode #x6C) '(:JMP :indirect-absolute 5))
   ((eq opcode #x40) '(:RTI :implied 6))
   ((eq opcode #x60) '(:RTS :implied 6))
   ((eq opcode #x10) '(:BPL :relative 2))
   ((eq opcode #x30) '(:BMI :relative 2))
   ((eq opcode #x50) '(:BVC :relative 2))
   ((eq opcode #x70) '(:BVS :relative 2))
   ((eq opcode #x90) '(:BCC :relative 2))
   ((eq opcode #xB0) '(:BCS :relative 2))
   ((eq opcode #xD0) '(:BNE :relative 2))
   ((eq opcode #xF0) '(:BEQ :relative 2))
   ((eq opcode #xF8) '(:SED :implied 2))
   ((eq opcode #xD8) '(:CLD :implied 2))
   ((eq opcode #x02) '(:NOP :implied 2))
   ((eq opcode #x12) '(:NOP :implied 2))
   ((eq opcode #x1A) '(:NOP :implied 2))
   ((eq opcode #x22) '(:NOP :implied 2))
   ((eq opcode #x32) '(:NOP :implied 2))
   ((eq opcode #x3A) '(:NOP :implied 2))
   ((eq opcode #x42) '(:NOP :implied 2))
   ((eq opcode #x52) '(:NOP :implied 2))
   ((eq opcode #x5A) '(:NOP :implied 2))
   ((eq opcode #x62) '(:NOP :implied 2))
   ((eq opcode #x72) '(:NOP :implied 2))
   ((eq opcode #x7A) '(:NOP :implied 2))
   ((eq opcode #x92) '(:NOP :implied 2))
   ((eq opcode #xB2) '(:NOP :implied 2))
   ((eq opcode #xD2) '(:NOP :implied 2))
   ((eq opcode #xDA) '(:NOP :implied 2))
   ((eq opcode #xF2) '(:NOP :implied 2))
   ((eq opcode #xFA) '(:NOP :implied 2))
   ((eq opcode #x04) '(:NOPD :implied 3))
   ((eq opcode #x14) '(:NOPD :implied 4))
   ((eq opcode #x34) '(:NOPD :implied 4))
   ((eq opcode #x44) '(:NOPD :implied 3))
   ((eq opcode #x54) '(:NOPD :implied 4))
   ((eq opcode #x64) '(:NOPD :implied 3))
   ((eq opcode #x74) '(:NOPD :implied 4))
   ((eq opcode #x80) '(:NOPD :implied 2))
   ((eq opcode #x82) '(:NOPD :implied 2))
   ((eq opcode #x89) '(:NOPD :implied 2))
   ((eq opcode #xC2) '(:NOPD :implied 2))
   ((eq opcode #xD4) '(:NOPD :implied 4))
   ((eq opcode #xE2) '(:NOPD :implied 3))
   ((eq opcode #xF4) '(:NOPD :implied 4))
   ((eq opcode #x0C) '(:NOPI :absolute 4))
   ((eq opcode #x1C) '(:NOPI :absolute-x 4))
   ((eq opcode #x3C) '(:NOPI :absolute-x 4))
   ((eq opcode #x5C) '(:NOPI :absolute-x 4))
   ((eq opcode #x7C) '(:NOPI :absolute-x 4))
   ((eq opcode #xDC) '(:NOPI :absolute-x 4))
   ((eq opcode #xFC) '(:NOPI :absolute-x 4))
   ((eq opcode #xA7) '(:LAX :zero-page 3))
   ((eq opcode #xB7) '(:LAX :zero-page-y 4))
   ((eq opcode #xAF) '(:LAX :absolute 4))
   ((eq opcode #xBF) '(:LAX :absolute-y 4))
   ((eq opcode #xA3) '(:LAX :pre-indexed-indirect 6))
   ((eq opcode #xB3) '(:LAX :post-indexed-indirect 5))
   ((eq opcode #x87) '(:SAX :zero-page 3))
   ((eq opcode #x97) '(:SAX :zero-page-y 4))
   ((eq opcode #x8F) '(:SAX :absolute 4))
   ((eq opcode #x83) '(:SAX :pre-indexed-indirect 6))
   ((eq opcode #xEB) '(:SBC :immediate 2))
   ((eq opcode #xC7) '(:DCP :zero-page 5))
   ((eq opcode #xD7) '(:DCP :zero-page-x 6))
   ((eq opcode #xCF) '(:DCP :absolute 6))
   ((eq opcode #xDF) '(:DCP :absolute-x 7))
   ((eq opcode #xDB) '(:DCP :absolute-y 7))
   ((eq opcode #xC3) '(:DCP :pre-indexed-indirect 8))
   ((eq opcode #xD3) '(:DCP :post-indexed-indirect 8))
   ((eq opcode #xE7) '(:ISB :zero-page 5))
   ((eq opcode #xF7) '(:ISB :zero-page-x 6))
   ((eq opcode #xEF) '(:ISB :absolute 6))
   ((eq opcode #xFF) '(:ISB :absolute-x 7))
   ((eq opcode #xFB) '(:ISB :absolute-y 7))
   ((eq opcode #xE3) '(:ISB :pre-indexed-indirect 8))
   ((eq opcode #xF3) '(:ISB :post-indexed-indirect 8))
   ((eq opcode #x07) '(:SLO :zero-page 5))
   ((eq opcode #x17) '(:SLO :zero-page-x 6))
   ((eq opcode #x0F) '(:SLO :absolute 6))
   ((eq opcode #x1F) '(:SLO :absolute-x 7))
   ((eq opcode #x1B) '(:SLO :absolute-y 7))
   ((eq opcode #x03) '(:SLO :pre-indexed-indirect 8))
   ((eq opcode #x13) '(:SLO :post-indexed-indirect 8))
   ((eq opcode #x27) '(:RLA :zero-page 5))
   ((eq opcode #x37) '(:RLA :zero-page-x 6))
   ((eq opcode #x2F) '(:RLA :absolute 6))
   ((eq opcode #x3F) '(:RLA :absolute-x 7))
   ((eq opcode #x3B) '(:RLA :absolute-y 7))
   ((eq opcode #x23) '(:RLA :pre-indexed-indirect 8))
   ((eq opcode #x33) '(:RLA :post-indexed-indirect 8))
   ((eq opcode #x47) '(:SRE :zero-page 5))
   ((eq opcode #x57) '(:SRE :zero-page-x 6))
   ((eq opcode #x4F) '(:SRE :absolute 6))
   ((eq opcode #x5F) '(:SRE :absolute-x 7))
   ((eq opcode #x5B) '(:SRE :absolute-y 7))
   ((eq opcode #x43) '(:SRE :pre-indexed-indirect 8))
   ((eq opcode #x53) '(:SRE :post-indexed-indirect 8))
   ((eq opcode #x67) '(:RRA :zero-page 5))
   ((eq opcode #x77) '(:RRA :zero-page-x 6))
   ((eq opcode #x6F) '(:RRA :absolute 6))
   ((eq opcode #x7F) '(:RRA :absolute-x 7))
   ((eq opcode #x7B) '(:RRA :absolute-y 7))
   ((eq opcode #x63) '(:RRA :pre-indexed-indirect 8))
   ((eq opcode #x73) '(:RRA :post-indexed-indirect 8))
   ;; need to check the following probably unsupported op
   ((eq opcode#x0B) '(:NOP :implied 2))
   ((eq opcode#x2B) '(:NOP :implied 2))
   ((eq opcode#x4B) '(:NOP :implied 2))
   ((eq opcode#x6B) '(:NOP :implied 2))
   ((eq opcode#x8B) '(:NOP :implied 2))
   ((eq opcode#x93) '(:NOP :implied 6))
   ((eq opcode#x9B) '(:NOP :implied 5))
   ((eq opcode#x9C) '(:NOP :implied 5))
   ((eq opcode#x9E) '(:NOP :implied 5))
   ((eq opcode#x9F) '(:NOP :implied 5))
   ((eq opcode#xAB) '(:NOP :implied 2))
   ((eq opcode#xBB) '(:NOP :implied 4))
   ((eq opcode#xCB) '(:NOP :implied 2))
   ))

(defun nes/cpu-init (cpu)
  "Init CPU."
  (nes/cpu-reset cpu))

(provide 'nes-cpu)

;; Local Variables:
;; coding: utf-8
;; End:
;;; nes-cpu.el ends here
